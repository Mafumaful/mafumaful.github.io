{"allContent":{"docusaurus-plugin-content-docs":{"default":{"loadedVersions":[{"versionName":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","path":"/docs","tagsPath":"/docs/tags","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs","editUrlLocalized":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/i18n/en/docusaurus-plugin-content-docs/current","isLast":true,"routePriority":-1,"sidebarFilePath":"/Users/miakho/web/mafumaful.github.io/sidebars.js","contentPath":"/Users/miakho/web/mafumaful.github.io/docs","contentPathLocalized":"/Users/miakho/web/mafumaful.github.io/i18n/en/docusaurus-plugin-content-docs/current","docs":[{"id":"intro","title":"Tutorial Intro","description":"Let's discover Docusaurus in less than 5 minutes.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"Tutorial - Basics","permalink":"/docs/category/tutorial---basics"}},{"id":"tutorial-basics/congratulations","title":"Congratulations!","description":"You have just learned the basics of Docusaurus and made some changes to the initial template.","source":"@site/docs/tutorial-basics/congratulations.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/congratulations","permalink":"/docs/tutorial-basics/congratulations","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/congratulations.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Deploy your site","permalink":"/docs/tutorial-basics/deploy-your-site"},"next":{"title":"Tutorial - Extras","permalink":"/docs/category/tutorial---extras"}},{"id":"tutorial-basics/create-a-blog-post","title":"Create a Blog Post","description":"Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed...","source":"@site/docs/tutorial-basics/create-a-blog-post.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/create-a-blog-post","permalink":"/docs/tutorial-basics/create-a-blog-post","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/create-a-blog-post.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Create a Document","permalink":"/docs/tutorial-basics/create-a-document"},"next":{"title":"Markdown Features","permalink":"/docs/tutorial-basics/markdown-features"}},{"id":"tutorial-basics/create-a-document","title":"Create a Document","description":"Documents are groups of pages connected through:","source":"@site/docs/tutorial-basics/create-a-document.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/create-a-document","permalink":"/docs/tutorial-basics/create-a-document","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/create-a-document.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Create a Page","permalink":"/docs/tutorial-basics/create-a-page"},"next":{"title":"Create a Blog Post","permalink":"/docs/tutorial-basics/create-a-blog-post"}},{"id":"tutorial-basics/create-a-page","title":"Create a Page","description":"Add Markdown or React files to src/pages to create a standalone page:","source":"@site/docs/tutorial-basics/create-a-page.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/create-a-page","permalink":"/docs/tutorial-basics/create-a-page","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/create-a-page.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Tutorial - Basics","permalink":"/docs/category/tutorial---basics"},"next":{"title":"Create a Document","permalink":"/docs/tutorial-basics/create-a-document"}},{"id":"tutorial-basics/deploy-your-site","title":"Deploy your site","description":"Docusaurus is a static-site-generator (also called Jamstack).","source":"@site/docs/tutorial-basics/deploy-your-site.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/deploy-your-site","permalink":"/docs/tutorial-basics/deploy-your-site","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/deploy-your-site.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Markdown Features","permalink":"/docs/tutorial-basics/markdown-features"},"next":{"title":"Congratulations!","permalink":"/docs/tutorial-basics/congratulations"}},{"id":"tutorial-basics/markdown-features","title":"Markdown Features","description":"Docusaurus supports Markdown and a few additional features.","source":"@site/docs/tutorial-basics/markdown-features.mdx","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/markdown-features","permalink":"/docs/tutorial-basics/markdown-features","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/markdown-features.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Create a Blog Post","permalink":"/docs/tutorial-basics/create-a-blog-post"},"next":{"title":"Deploy your site","permalink":"/docs/tutorial-basics/deploy-your-site"}},{"id":"tutorial-extras/manage-docs-versions","title":"Manage Docs Versions","description":"Docusaurus can manage multiple versions of your docs.","source":"@site/docs/tutorial-extras/manage-docs-versions.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/manage-docs-versions","permalink":"/docs/tutorial-extras/manage-docs-versions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-extras/manage-docs-versions.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Tutorial - Extras","permalink":"/docs/category/tutorial---extras"},"next":{"title":"Translate your site","permalink":"/docs/tutorial-extras/translate-your-site"}},{"id":"tutorial-extras/translate-your-site","title":"Translate your site","description":"Let's translate docs/intro.md to French.","source":"@site/docs/tutorial-extras/translate-your-site.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/translate-your-site","permalink":"/docs/tutorial-extras/translate-your-site","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-extras/translate-your-site.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Manage Docs Versions","permalink":"/docs/tutorial-extras/manage-docs-versions"}}],"drafts":[],"sidebars":{"tutorialSidebar":[{"type":"doc","id":"intro"},{"type":"category","label":"Tutorial - Basics","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"tutorial-basics/create-a-page"},{"type":"doc","id":"tutorial-basics/create-a-document"},{"type":"doc","id":"tutorial-basics/create-a-blog-post"},{"type":"doc","id":"tutorial-basics/markdown-features"},{"type":"doc","id":"tutorial-basics/deploy-your-site"},{"type":"doc","id":"tutorial-basics/congratulations"}],"link":{"type":"generated-index","description":"5 minutes to learn the most important Docusaurus concepts.","slug":"/category/tutorial---basics","permalink":"/docs/category/tutorial---basics"}},{"type":"category","label":"Tutorial - Extras","collapsible":true,"collapsed":true,"items":[{"type":"doc","id":"tutorial-extras/manage-docs-versions"},{"type":"doc","id":"tutorial-extras/translate-your-site"}],"link":{"type":"generated-index","slug":"/category/tutorial---extras","permalink":"/docs/category/tutorial---extras"}}]}}]}},"docusaurus-plugin-content-blog":{"default":{"blogSidebarTitle":"Recent posts","blogPosts":[{"id":"blog-post","metadata":{"permalink":"/blog/blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-01-10-blog-post.md","source":"@site/blog/2025-01-10-blog-post.md","title":"Blog Post","description":"My First blog...","date":"2025-01-10T00:00:00.000Z","tags":[{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.77,"hasTruncateMarker":true,"authors":[{"name":"mafumaful","title":"Student @ UWaterloo","url":"https://github.com/mafumaful","page":{"permalink":"/blog/authors/mafumaful"},"socials":{"x":"https://x.com/MasjfM","github":"https://github.com/mafumaful"},"imageURL":"https://github.com/mafumaful.png","key":"mafumaful"}],"frontMatter":{"slug":"blog-post","title":"Blog Post","authors":["mafumaful"],"tags":["hello","docusaurus"]},"unlisted":false,"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"My First blog...\n\n<!-- truncate -->\n\nIt's my first blog thanks to docusaurus! 兜兜转转发现这个框架是最适合我的hhh。理论上说，这个是我在网站上发布的第一篇博客，但是由于之前也是用markdown做了很多优秀的项目，所以我想看看能不能把之前的项目加入到当前的网站上去以充实我网页的内容。\n\nLet's try some math equations using KaTeX!\n\nInline math equation: $E = mc^2$\n\nDisplay math equation:\n\n$$\n\\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots}}}}\n$$\n\nAnother example:\n\n$$\n\\begin{aligned}\n\\frac{\\partial \\mathcal{L}}{\\partial w} &= 2x(xw - y) \\\\\n\\frac{\\partial \\mathcal{L}}{\\partial b} &= 2(xw + b - y)\n\\end{aligned}\n$$"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-26-welcome/index.md","source":"@site/blog/2021-08-26-welcome/index.md","title":"Welcome","description":"Docusaurus blogging features are powered by the blog plugin.","date":"2021-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description"},{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.465,"hasTruncateMarker":true,"authors":[{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["slorber","yangshun"],"tags":["facebook","hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"Blog Post","permalink":"/blog/blog-post"},"nextItem":{"title":"标定平面测距","permalink":"/blog/calibrated-plane"}},"content":"[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\n\nHere are a few tips you might find useful.\n\n<!-- truncate -->\n\nSimply add Markdown files (or folders) to the `blog` directory.\n\nRegular blog authors can be added to `authors.yml`.\n\nThe blog post date can be extracted from filenames, such as:\n\n- `2019-05-30-welcome.md`\n- `2019-05-30-welcome/index.md`\n\nA blog post folder can be convenient to co-locate blog post images:\n\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\n\nThe blog supports tags as well!\n\n**And if you don't want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config."},{"id":"calibrated-plane","metadata":{"permalink":"/blog/calibrated-plane","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2020-12-21-calibrated-plane-ranging/index.md","source":"@site/blog/2020-12-21-calibrated-plane-ranging/index.md","title":"标定平面测距","description":"---","date":"2020-12-21T00:00:00.000Z","tags":[{"inline":false,"label":"algorithm","permalink":"/blog/tags/algorithm","description":"algorithm tag description"}],"readingTime":34.43,"hasTruncateMarker":true,"authors":[{"name":"mafumaful","title":"Student @ UWaterloo","url":"https://github.com/mafumaful","page":{"permalink":"/blog/authors/mafumaful"},"socials":{"x":"https://x.com/MasjfM","github":"https://github.com/mafumaful"},"imageURL":"https://github.com/mafumaful.png","key":"mafumaful"}],"frontMatter":{"slug":"calibrated-plane","title":"标定平面测距","authors":["mafumaful"],"tags":["algorithm"]},"unlisted":false,"prevItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"---\n\n用matlab标定摄像机以后，用python在标定平面内建立世界坐标系并测距:sailboat:\n\n由于是很早写的代码了，里面文件好多都没有用相对路径，可移植性可能比较差，建议使用相对路径:cake:\n\n里面的标定板是一个可变参数，随着你标定板正方形边长改变而改变:golf:\n\n用halcon会比这个快很多，但是我看到之前没有人用opencv做，我就尝试自己做了一下:goal_net:\n\n代码就看后面附录吧，就不单独整理出来了:smile:\n\n强烈建议用typora查看！！！！我好多东西都没有完完全全显示出来（比如latex文本，还有好多Typora好多内置的语句），如果不想用typora看的话，那就用html看吧~\n\n<!-- truncate -->\n\n---\n\n# 1设计任务\n\n## 1.1任务要求\n\n摄像机标定要求自制标定板，使用网络摄像机或手机摄像头进行标定。将标定的摄像机内参和外参进行保存。设计测量方案，使用标定过的摄像机对包含垂直边缘的物品（直尺刻度线，矩形物体边缘等）进行距离或边长的测量。标定过程和测量过程，均需要保持摄像机与测量平面之间的距离固定，物品高度不能过高，否则影响测量结果。给出设计的中间过程和截图以及最终测量结果，并对测量结果进行误差计算和分析。根据任务书要求，完成以下设计任务：\n\n系统整体方案设计，包括\n\n1. 课题分析，设计测量方案，测量对象的确定；\n2. 系统总体结构框图（或流程图）。\n\n结合Halcon（或open CV）软件，写出各功能模块的实现及相应的代码。\n\n1. 标定板制作；\n2. 摄像机标定；\n3. 对设计方案中垂直于测量矩形框的直边进行提取，并测量直边之间的距离，从而得到平面测量对象的尺寸；\n4. 对测量值与实际尺寸误差进行一定的分析和改进\n5. 多次测量，计算出测量的平均值和标准差\n\n \n\n## 1.2任务分析\n\n本次任务主程序可以分为三块:相机拍摄，相机标定，测量三大块。其中，相机拍摄为相机标定主要任务是获取图像，存储的是图像的参数；相机标定的主要任务是获取相机的内参；在测量里面，我们需要用标定板来确定相机的外参，然后由于我们在测量图像外参的时候，默认将标定板作为参考坐标系，所以只要将相机成像平面中的点投影到Z=0时的成像平面就可以了。\n\n由于本次实验我采用的是选用红色来做测量的对象，所以我需要对图像阈值做出提取，比如，我在这里就进行了HSV提取。\n\n```mermaid\nclassDiagram\n相机拍摄 --|> 相机标定 : 提供图像参数\n相机拍摄 : 图像\n相机拍摄 : GetImages()\n相机标定 : 图像畸变矩阵\n相机标定 : 相机矩阵\n相机标定 : GetImageParam()\n相机标定 --|> 测量 : 提供相机内参\n测量 : 映射矩阵\n测量 : 距离\n测量 : 三维空间点\n测量 : 长度\n测量 : 相机外参\n测量 : ProjectionTransformation()\n测量 : GetContours()\n测量 : CarculateTransformMatrix()\n相机拍摄--|>测量 : 提供被测图像\nHSV提取..|>测量 : 提供目标图像的阈值\nHSV提取 : HSV各项参数\nHSV提取 : GetParams()\n相机拍摄..|>HSV提取 : 提供HSV参照图像\n```\n\n大致的设计方案如上图所示。\n\n \n\n# 2设计原理\n\n## 2.1相机的成像原理\n\n我们熟知的摄像机是由光线透过透镜折射，反射到成像平面形成的，本质是利用二维图像获取三维信息的过程。所以我们可以通过成像的状况来反映三维世界中的信息。\n\n![201112192220075246.png](./201112192220075246.png)\n\n但是，现实模型总会与理想模型存在一些偏差，这里的偏差主要就是相机内参与畸变系数所导致的。由于每一个相机都是利用的透镜成像原理，所以很容易产生桶形畸变或者是枕形畸变。所以一个三维的图像到OpenCV显示的画面需要经历三个变化，这三个变化对应的参数分别是相机位姿参数，畸变技术，相机内参。由此可得：\n\n$$\nZ_c\\left[ \\begin{array}{c}u\\\\v\\\\1\\end{array} \\right] =\n\\left[\\begin{array}{ccc}\n\\frac{1}{dx} & 0 & u_0\\\\\n0 & \\frac{1}{dy} & v_0\\\\\n0 & 0 & 1\n\\end{array}\\right]\n\\left[\\begin{array}{cccc}\nf & 0 & 0 & 0\\\\\n0 & f & 0 & 0\\\\\n0 & 0 & 1 & 0\n\\end{array}\\right]\n\\left[\\begin{array}{c|c}R&t\\\\\\hline 0^T&1\\end{array}\\right]\\left[\\begin{array}{c}X\\\\Y\\\\Z\\\\1\\end{array}\\right]\n\\left[\\begin{array}{c}\nX\\\\Y\\\\Z\\\\1\n\\end{array}\\right]\n$$\n\n其中：\n\n$\\left[\\begin{array}{c|c}R&t\\\\\\hline 0^T&1\\end{array}\\right]\\left[\\begin{array}{c}X\\\\Y\\\\Z\\\\1\\end{array}\\right]$ 表示的是相机与世界的关系，\n\n$\\left[\\begin{array}{cccc}f&0&0&0\\\\0&f&0&0\\\\0&0&1&0\\end{array}\\right]\\left[\\begin{array}{c|c}R&t\\\\\\hline 0^T&1\\end{array}\\right]\\left[\\begin{array}{c}X\\\\Y\\\\Z\\\\1\\end{array}\\right]$ 表示的是三维空间与投影的关系，\n\n等式的右边，也就是\n\n$\\left[\\begin{array}{ccc}\\frac{1}{dx}&0&u_0\\\\0&\\frac{1}{dy}&v_0\\\\0&0&1\\end{array}\\right]\\left[\\begin{array}{cccc}f&0&0&0\\\\0&f&0&0\\\\0&0&1&0\\end{array}\\right]\\left[\\begin{array}{c|c}R&t\\\\\\hline 0^T&1\\end{array}\\right]\\left[\\begin{array}{c}X\\\\Y\\\\Z\\\\1\\end{array}\\right]$\n\n表示的是像素平面与三维空间的关系。经过三个矩阵的变化，我们就可以得到相机在摄像平面内像素的坐标位置。\n\n## 2.2深度的测量原理\n\n但是，由于我们课题内使用的是一个单目摄像机，如果不移动相机，我们是无法获取三维平面内的尺度信息和深度信息的。但是我们可以获取三维平面内的比例关系。这时候我们需要知道更多的参数。\n\n在这次的课题里面，我们需要的参数有两个，一个是相机的位姿参数，一个是成像平面。知道了这两个参数，我们就可以将摄像机内二维平面内的点投射到三维的坐标中去，再利用三维坐标轻松算出点与点之间的距离。这个课题里面，我们默认将世界坐标系的原点放在标定板第一个角点上。所以，我们只需要将成像平面设置为Z=0，即XOY面就可以了，这时我们便获得了需要计算深度信息的所有参数。\n\n\n# 3方案及各个功能模块的设计\n\n## 3.1硬件部分设计\n\n### 3.1.1标定板的制作\n\n标定板采用的是MATLAB制作的，MATLAB里面输入如下代码：\n\n```matlab\nJ=(checkerboard(300,4,5)>0.5);\nfigure,imshow(J);\n```\n\n就可以制作出如下图所示的标定板：\n\n![image-20200525145713086](./image-20200525145713086.png)\n\n然后在网上查阅资料可以知道，iPad的屏幕宽度是196.6mm。\n\n![image-20200525150824005](./image-20200525150824005.png)\n\n\n如上图所示，iPad宽度上的方格数是8个，所以每个方格的长度是$196.6mm\\div 8=24.575mm$。摄像机标定部分，首先我用opencv + python部分写了一个存储图像的代码，作为标定摄像机的模块。\n\n测量时返回摄像机位姿的标定板摆放：\n\n![image-20200525151516388](./image-20200525151516388.png)\n\n### 3.1.2标定图像的制作\n\n为了方便测量，我选用了一个红色的长方形来做测量的模块。如下图所示：\n\n![image-20200525151852153](./image-20200525151852153.png)\n\n实际长度在118.4-118.5毫米。\n\n## 3.2软件部分设计\n\n### 3.2.1程序总流程图设计\n\n```flow\nst=>start: 开始\nphoto=>subroutine: 拍摄图像\ncalib=>subroutine: 相机标定\nmeasure=>subroutine: 测量\nend=>end: 结束\n\nst->photo\nphoto->calib\ncalib->measure\nmeasure->end\n```\n\n如上图所示，程序的主流程图先是拍摄图像，然后根据图像的拍摄结果进行相机的内参标定，测量目标图像。\n\n### 3.2.2拍摄图像部分流程图设计\n\n```flow\nst=>start: 开始\nget=>operation: 获取摄像头图像\nsavepath=>operation: 设置图像保存路径\n\ndetect=>operation: 检测按键\ncamera=>operation: 获取图像\ncond1=>condition: 检测到按键为‘s’？\ncond2=>condition: 检测按键为‘q’？\nsave=>operation: 保存图像\ned=>end: 结束\n\nst->get(right)->savepath->detect\ndetect->camera->cond1\ncond1(no)->cond2\ncond1(yes,right)->save(right)->detect\ncond2(yes)->ed\ncond2(no)->detect\n\n\n```\n\n如上图所示，拍摄图像的步骤很简单，主要是采用了Mac的内置摄像头部分，检测按键来进行拍照。如果检测的按键是“s‘的话，那么将图像保存在存储路径里面，如果检测到的按键是”q“的话，那么退出图像的检测环节。\n\n### 3.2.3相机标定的流程图设计\n\n```flow\nst=>start: 开始\nread=>operation: 读取图像\ngray=>operation: 将图像转变为灰度图\nconer=>operation: 寻找角点\ncond1=>condition: 找到角点？\ntake=>operation: 把角点列入参照点\nsss=>operation: 存储角点\nshow=>operation: 显示角点\nfind=>condition: 找到足够的角点？\ncalib=>operation: 标定\nend=>end: 结束\n\nst->read->gray->coner(right)->cond1\ncond1(no,right)->find(no)->coner\nfind(yes)->show->calib(right)->end\ncond1(yes)->take->sss(left)->coner\n```\n\n如上图所示，相机标定主要是对棋盘角点的寻找，然后再储存角点，如果储存到了足够多的角点的话，就退出程序的循环，进行标定。\n\n### 3.2.4测量的流程图设计\n\n```flow\nst=>start: 开始\nread=>operation: 读取相机的内参，标定平面图像\nopen=>operation: 根据标定板读取相机外参\nread2=>operation: 读取待测图像\nmeasure=>subroutine: 计算实际长度\ncond1=>condition: 图像是否读取完毕？\nend=>end: 结束，并打印输出结果\n\nst->read(right)->open->read2->measure(right)->cond1\ncond1(yes)->end\ncond1(no)->read2\n```\n\n如上图所示，程序的主要思路是根据标定板得到相机的外参，然后根据摄像机的外参来计算目标图像的参数。秉持着严谨的思想，我采用了旋转被测物体，多次测量求平均值的方法，在之后的数据分析中，也需要将异常数值剔除。\n\n### 3.2.5计算距离的流程图设计\n\n```flow\nst=>start: 入口\nmask=>operation: 将图像HSV提取，提取出目标方块\ncontour=>operation: 提取目标的轮廓\nmax_con=>operation: 遍历所有的轮廓找出最大的轮廓\napproxPlo=>operation: 拟合一个四边形，获取角点\nworld=>operation: 将角点投射到世界坐标系中\ndis=>operation: 计算距离&并打印输出结果\nend=>end: 出口\n\nst->mask->contour(right)->max_con->approxPlo(right)->world->dis->end\n\n```\n\n如图所示，这里用到的方法是根据提取出来的轮廓拟 q合一个四边形，根据拟合出来的四边形得出其角点，根据角点变换到3为坐标中去，根据三维坐标系中的点来计算距离参数，并返回。\n\n### 3.2.6附加程序(HSV):提取的流程图设计\n\n```flow\nst=>start: 开始\nread=>operation: 读取图像\nbuild=>operation: 建立一个HSV滑块\nm=>operation: 读取滑块数值\nkk=>operation: 根据滑块的阈值分割图像\njk=>condition: 检测到的按键为q?\nop=>operation: 输出HSV阈值的大小\nend=>end: 结束\nst->read->build(right)->m->kk(right)->jk\njk(no)->m\njk(yes)->op->end\n```\n\n如图所示，这个程序的目的是，检测到HSV空间里的阈值，使其能够正好将目标图像的正方体区分开来，然后在提取HSV数值以后，返回一个阈值列表。\n\n## 3.3部分重要代码分析\n\n### 3.3.1拍摄部分\n\n```python\nif key == ord('s'):\n\t\tcv.imwrite(filepath +img_name + str(a)+'.png',frame)     # 按s截取图像\n\t\ta = a + 1               # 改变截取图像的名称\nif key == ord('q'):\n\t\tbreak                   # 如果检测到按键为esc，就退出摄像\n```\n\n这里是个保存图像的函数，如果检测到按键是”s“，那么将图像保存在相应的路径里面，如果检测到按键按下的是”q“，则退出循环，关闭摄像机。\n\n### 3.3.2相机内参标定部分\n\n```python\nret, corners = cv2.findChessboardCorners(gray, (7,5), None)\n# 如果找出角点，把角点加入坐标系内\nif ret == True:\n    objpoints.append(objp*30)\n    # 参照criteria进行亚像素检验\n    corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)\n    imgpoints.append(corners2)\n    # 将角点显示出来\n    img = cv2.drawChessboardCorners(img, (7,5), corners2,ret)\n    cv2.imwrite(sys.path[0]+\"/标定结果/\"+\"result\"+ str(a)+\".png\", img)\n    a = a+1\n```\n\nfindChessboardCorners是一个检测标定板角点的函数，如果检测到了角点，就以criteria的规则进行亚像素检验，然后再将所有的角点储存下来，将检测到的角点显示并且将显示角点的图像保存下来。\n\n```python\nif fname == images[-1]:\n    ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1],None,None)\n```\n\n这里的主要目的是在最后一次的标定后，针对角点及其对应点进行摄像机内参的标定。\n\n### 3.3.3测量部分\n\n```python\nif Find:\n    # 获取更精确的角点位置(亚像素精度)\n    exact_corners = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)\n    # 获取外参，其中rvec是旋转矩阵，tvec是平移矩阵\n    _,rvec, tvec, inliers = cv2.solvePnPRansac(world_point, exact_corners, IntrinsicMatrix, distC\n    # 获取两个平面(像素平面与实际平面)的映射关系,其中RMat是相机平面到Z=0轴的投影\n    Mat = cv2.findHomography(D_2_point, exact_corners)[0]\n    RMat = cv2.findHomography(exact_corners, D_2_point)[0]\n    \n    #print(np.transpose(np.dot(Mat,[[24.575*3,0],[0,24.575*3],[1,1]])))\n    # 这里打印的是一个投影的值\n    # 根据3D坐标，获取投影的二维坐标\n    imgpts, jac = cv2.projectPoints(axis, rvec, tvec, IntrinsicMatrix, distCoeffs)\n    # 可视化角点，画出图像\n    img = draw(image, corners, imgpts)\n    # cv2.imshow('img', img)\n    return [Mat,RMat,corners,imgpts]\n```\n\n同样的，这里依然进行摄像机标定，不过这里进行的是摄像机外参的标定，通过投影的方法找到相机的内参和外参，再返回一个相机位姿矩阵。\n\n```python\ncontours, hierarchy = cv2.findContours(image_2, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\nfor contour in contours:\n    arclength = cv2.arcLength(contour, True)\n    # print(arclength)\n    a.append(arclength) # 长度保存在数组中\nmaxlen = max(a)\nfor contour in contours:\n    arclength = cv2.arcLength(contour, True)\n    if arclength == maxlen:\n        dot = cv2.approxPolyDP(contour,5,True)\n        dot = np.int0(dot)\n        cv2.drawContours(image, [dot], 0, (0, 0, 0), 1)\n```\n\n用HSV参数进行阈值化处理后，findContours作用是找出目标物体的外轮廓，返回的contour是轮廓的点集。考虑到在图像里面会有很多干扰点，所以我们要将最大的轮廓给过滤出来。approxPolyDP表示的是多边形拟合，在这个函数中，返回的是图像中四边形的四个角点。根据图像里面返回的四个角点，以及相机位姿及其内参，三维空间里平面参数，我们很容易将图像的几个点在三维空间里面描述出来。也就很容易知道四边形对应的矩形几个边的边长了。\n\n \n\n# 4结果分析及总结\n\n## 4.1程序运行结果\n\n### 4.1.1拍摄部分\n\n拍出来以下的图像以备相机内参标定：\n\n![标定图像](./标定图像.png)\n\n拍出以下图片准备外参标定：\n\n![aaa](./aaa.png)\n\n拍出以下图片准备测量长度：\n\n![目标测量图像](./目标测量图像.png)\n\n### 4.1.2相机标定部分\n\nMATLAB结合标定出来的位姿，用MATLAB作图如下，一共选取了5张图像作为标定的图像：\n\n![image-20200525172949810](./image-20200525172949810.png)\n\n\n测量出来的相机内参矩阵为：\n\n$$\n\\begin{bmatrix}\n916.2197 & 0 & 622.7878 \\\\\n0 & 914.8909 & 261.5797 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n\n在程序里面用 `IntrinsicMatrix` 来表示。\n\n相机畸变矩阵为：\n\n$$\n\\begin{bmatrix}\n-0.1671 \\\\\n0.9553 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n$$\n\n在程序里面用 `distCoeffs` 来表示。\n\n### 4.1.3测量部分：\n\n输出的结果如下所示：\n\n> 世界坐标下的角点：\n>\n> [[137.88112481  -4.24766315   0.        ]\n>\n> [ 28.53543319  40.02809197   0.        ]\n>\n> [ 55.77381169 108.36633628   0.        ]\n>\n> [165.90828778  64.39100409   0.        ]]\n>\n> 长方形边长的集合：\n>\n> [ 73.5666018   74.14032982 117.96958408 118.58934466]\n>\n> 取平均数:\n>\n> 宽： 73.85346580588386 毫米\n>\n> 长： 118.27946436719735 毫米\n>\n> \n>\n> 世界坐标下的角点：\n>\n> [[ 66.02325053   2.18656177   0.        ]\n>\n> [ 30.74511718  66.73356836   0.        ]\n>\n> [135.16197346 123.50090902   0.        ]\n>\n> [170.07975683  58.43069731   0.        ]]\n>\n> 长方形边长的集合：\n>\n> [ 73.55856682  73.8470314  118.28423093 118.85037165]\n>\n> 取平均数:\n>\n> 宽： 73.70279911093833 毫米\n>\n> 长： 118.56730128920334 毫米\n>\n> \n>\n> 世界坐标下的角点：\n>\n> [[108.70789454 -17.01865902   0.        ]\n>\n> [ -9.30864053  -3.7926789    0.        ]\n>\n> [ -0.30755372  70.08360104   0.        ]\n>\n> [116.78537506  55.62439688   0.        ]]\n>\n> 长方形边长的集合：\n>\n> [ 73.09076044  74.42260612 117.98229763 118.75533294]\n>\n> 取平均数:\n>\n> 宽： 73.75668328220843 毫米\n>\n> 长： 118.36881528254716 毫米\n>\n> \n>\n> 世界坐标下的角点：\n>\n> [[ 34.02336852 -14.89701085   0.        ]\n>\n> [ -0.48205567  50.23335675   0.        ]\n>\n> [103.33365511 106.21994712   0.        ]\n>\n> [138.5286085   41.57480383   0.        ]]\n>\n> 长方形边长的集合：\n>\n> [ 73.60488635  73.70609936 117.94998985 118.78725115]\n>\n> 取平均数:\n>\n> 宽： 73.6554928520593 毫米\n>\n> 长： 118.36862049933106 毫米\n>\n> \n>\n> 世界坐标下的角点：\n>\n> [[123.41620928   2.26868745   0.        ]\n>\n> [  5.71122519  16.21565989   0.        ]\n>\n> [ 14.16367519  89.82432698   0.        ]\n>\n> [131.98781159  75.25006324   0.        ]]\n>\n> 长方形边长的集合：\n>\n> [ 73.48301558  74.09237331 118.52839878 118.72209685]\n>\n> 取平均数:\n>\n> 宽： 73.78769444208488 毫米\n>\n> 长： 118.62524781649668 毫米\n>\n> \n>\n> 总平均宽度： 73.75122709863497 毫米\n>\n> 总平均长度： 118.4418898509551 毫米\n\n坐标系标定以后，并将坐标系储存了下来，显示图像如下：\n\n![画出坐标系后的图像](./画出坐标系后的图像.png)\n\n其中，图上的蓝，绿，红对应的是世界坐标系中的x轴，y轴与z轴，三个坐标轴相交的地方就是世界坐标系的原点。\n\n\n\n## 4.2结果分析\n\n### 4.2.1相机部分\n\n相机拍摄的图像成功保存在了规定的文件夹下面。\n\n### 4.2.2标定部分\n\n![image-20200525194218508](./image-20200525194218508.png)\n\n结合MATLAB很容易就知道平均像素误差，大概是在0.14像素左右，在可以接受的范围内。得到了相机的内参和畸变系数。\n\n### 4.2.3测量部分\n\n因为是分多次测量，所以得到了不同的数值，但是大致分布都是差不多的，如下图所示，点在平面里较为集中误差较小(根据场和宽的坐标已经在图里用蓝色五角星标出)。图中的点在图像里面较为集中，误差在毫米以内，达到了设计要求！\n\n![image-20200525155604198](./image-20200525155604198.png)\n\n由样本标准差公式可知：\n$$\ns = \\sqrt { s^2} = \\sqrt {\\frac{\\sum\\limits_{ i = 1 } ^ { n } ( x _ { i } - \\bar { x } ) ^ { 2 } }{n-1}}\\tag{2}\n$$\n将数据代入公式(2)，得知题中的长度的标准差为0.1478mm，宽度的标准差为0.1326mm。\n\n由宽度平均值73.75mm，与长度平均值118.44mm，协方差矩阵可以由MATLAB计算得来，置信区间如下图所示：\n\n![image-20200525165730958](./image-20200525165730958.png)\n\n不难发现，x轴对应的对象也就是长方形长度的不确定性要更大一点。长的取值主要集中在118-119之间。可以发现，长度和宽度还是存在一定的关联，当长度测量的偏长的时候，宽度大概率也会偏长。\n\n \n\n## 4.3总结\n\n改进措施：\n\n对测量值与实际误差进行一定的分析和改进\n\n1. 在一开始，采用了纸质标定板的形式。但是，在多次试验中发现，纸质的标定板容易在标定的时候发生弯曲的情况，也容易在打印的过程中出现漏墨的情况导致黑色分布不均匀。在测量的时候，尺子的精度在毫米的级别，所以很容易引起误差。我想到了用iPad来把标定板显示出来，根据iPad屏幕的长度来计算方格的尺寸大小。这样就可以将误差一下子降低到像素级别。结合我iPad的分辨率264ppi很容易得出，误差的量级在0.1mm。\n2. 采用多次测量的手段，去掉极端值，选用90%置信区间的点作为使用的长度反复测量可以消除偶然误差。\n3. 在一开始，我用的是最小矩形来拟合测量线段的长度的，但是考虑到现实中由于图像的透视关系，我们的正方形在成像平面中的形状会随着相机的位姿改变而改变，所以说，这并不是一个规则的正方形。因此，我在一开始用正方形拟合的时候总是会出现误差。所以，我选用了四边形拟合的方法来检测图形的角点。\n\n感想：\n\n这次作业可谓是花费了两整天的时间，从设计程序，到作图都是各处查阅资料，也饶了不少弯路。本来可以用halcon很快捷地完成这次任务的，但是我觉得用halcon的话，我对相机标定，对成像平面的各种变化的认识可能就没有用OpenCV来得更深刻一些。在这次作业中，虽然累了一点，但是在编写完成以后的成就感还是爆棚的。\n\n虽然累了一点，但是我学到了很多的实践知识。时间几乎都是用在了搜索网上资料上了。但是感觉蛮值得的。其实里面最花时间的部分还是属于测量长度这部分的代码了，当时想了好几种测量方案，但是感觉不是很难实现就是精度不够。最后采用了四边形拟合的方法，我很庆幸在我将要放弃的时候，最后所搜了一把，发现了多边形拟合函数，一下子便解决了我的问题。\n\n```mermaid\ngantt\ntitle 作业日程\ndateFormat DD-HH-mm\naxisFormat %H:%m\nsection 周五(5.22)\n程序设计:active,des1,24-08-00,10h\n标定板选用和制作:done,24-14-00,30m\n标定板的重新制作:active,24-19-40,10m\nsection 周六(5.23)\n标定程序编写:active,24-08-00,4h\n查阅资料:active,crit,24-08-00,2h\n拍照:active,crit,des2,24-18-50,90m\n标定:active,24-20-20,30m\nsection 周日(5.24)\n摄像机标定编写:active,24-08-00,5h\n查阅资料:active,crit,24-09-00,2h\n测量程序编写:crit,24-14-00,6h\nsection 周一(5.25)\nmarkdown学习:active,des4,24-08-00,2h\n写报告:active,24-10-30,2h\n写报告:active,24-14-00,5h\n```\n\n \n\n# 5附录\n\n## 5.1相机拍照部分代码\n\n```python\n#! /usr/bin/env python3\n#! _*_ coding: utf-8 _*_\n\nimport cv2 as cv\n\nif __name__ == \"__main__\":\n    cap = cv.VideoCapture(0)        # 获取摄像头图像\n    img_name = 'calib'              # 定义一个字符名\n    filepath = '/Users/mafumaful/Desktop/学习/./document/期末大作业-----------------/截取图像/'\n    a = 1\n    while True:\n        key = cv.waitKey(1) & 0xff\n        ret,frame = cap.read()      # 读取图像\n        frame_f = cv.flip(frame,1)    # 获得图像的镜像\n        cv.imshow(\"camera\",frame_f)   # 显示图像\n        if key == ord('s'):\n            cv.imwrite(filepath +img_name + str(a)+'.png',frame)     # 按s截取图像\n            a = a + 1               # 改变截取图像的名称\n        if key == ord('q'):\n            break                   # 如果检测到按键为esc，就退出摄像\n\n\n\n```\n\n## 5.2相机标定部分代码\n\n```python\n#! /usr/bin/env python3\n#! _*_ coding: utf-8 _*_\n\nimport glob\n\nimport cv2\nimport numpy as np\nimport sys\n\n# termination criteria\ncriteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)\n\nobjp = np.zeros((5*7,3), np.float32)\nobjp[:,:2] = np.mgrid[0:7,0:5].T.reshape(-1,2)\na = 1\nobjpoints = [] # 在世界坐标系中的3-D点\nimgpoints = [] # 在图像坐标系中的点\n\nimages = glob.glob(sys.path[0]+\"/标定图像/*.png\") # 加载所有的图像的路径\nfor fname in images:\n    img = cv2.imread(fname)\n    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\n\n    # 寻找出角点\n    ret, corners = cv2.findChessboardCorners(gray, (7,5), None)\n\n    # 如果找出角点，把角点加入坐标系内\n    if ret == True:\n        objpoints.append(objp*30)\n        # 参照criteria进行亚像素检验\n        corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)\n        imgpoints.append(corners2)\n\n        # 将角点显示出来\n        img = cv2.drawChessboardCorners(img, (7,5), corners2,ret)\n        cv2.imwrite(sys.path[0]+\"/标定结果/\"+\"result\"+ str(a)+\".png\", img)\n        a = a+1\n    \n    # 在最后一次循环中，将所有进行标定\n    if fname == images[-1]:\n        ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1],None,None)\n\ncv2.destroyAllWindows()\n```\n\n## 5.3测量部分代码\n\n```python\n#! /usr/bin/env python3\n#! _*_ coding: utf-8 _*_\n\nimport cv2\nimport numpy as np\nimport glob\nimport sys\n\n# 读取相机内参\n\n# 相机固定矩阵\nIntrinsicMatrix = np.ones((3,3))\nIntrinsicMatrix[0][0]=916.1205\nIntrinsicMatrix[0][1]=0\nIntrinsicMatrix[0][2]=618.0472\nIntrinsicMatrix[1][0]=0\nIntrinsicMatrix[1][1]=913.5313\nIntrinsicMatrix[1][2]=361.3608\nIntrinsicMatrix[2][0]=0\nIntrinsicMatrix[2][1]=0\nIntrinsicMatrix[2][2]=1\n# 畸变矩阵\ndistCoeffs = np.ones((5,1))\ndistCoeffs[0][0]=-0.2158\ndistCoeffs[1][0]=1.4380\ndistCoeffs[2][0]=0\ndistCoeffs[3][0]=0\ndistCoeffs[4][0]=0\n\n\ndef distance_2d(a,b):\n    return np.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2)\n\ndef draw(img, corners, imgpts):\n    corner = tuple(corners[0].ravel())\n    img = cv2.line(img, corner, tuple(imgpts[0].ravel()), (255,0,0), 2)\n    img = cv2.line(img, corner, tuple(imgpts[1].ravel()), (0,255,0), 2)\n    img = cv2.line(img, corner, tuple(imgpts[2].ravel()), (0,0,255), 2)\n    return img\n\n# 标定图像保存路径\nphoto_path = sys.path[0]+\"/标定板位姿测量/aaa.png\"\n# 每一个方格的边长为24.575mm\nlength = 24.575\n\n# 标定图像\ndef calibration_photo(photo_path):\n    # 设置要标定的角点个数\n    x_nums = 7                                                          # x方向上的角点个数\n    y_nums = 5\n    # 设置(生成)标定图在世界坐标中的坐标\n    world_point = np.zeros((x_nums * y_nums,3),np.float32)            # 生成x_nums*y_nums个坐标，每个坐标包含x,y,z三个元素\n    world_point[:,:2] = np.mgrid[:x_nums,:y_nums].T.reshape(-1, 2)    # mgrid[]生成包含两个二维矩阵的矩阵，每个矩阵都有x_nums列,y_nums行\n                                                                        # .T矩阵的转置\n                                                                        # reshape()重新规划矩阵，但不改变矩阵元素\n    # 实际长度还要乘以一个正方形的边长24.474mm\n    world_point=world_point*length\n    # 对应的2D坐标，在之后的映射关系里可以用到\n    D_2_point = np.mgrid[:x_nums,:y_nums].T.reshape(-1, 2)*length\n    # 设置世界坐标的坐标\n    axis = np.float32([[3,0,0], [0,3,0], [0,0,-3]]).reshape(-1,3)\n    axis = axis*length\n    # 设置角点查找限制\n    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER,30,0.001)\n\n    image = cv2.imread(photo_path)\n\n    gray = cv2.cvtColor(image,cv2.COLOR_RGB2GRAY)\n    # 查找角点\n    Find, corners = cv2.findChessboardCorners(gray,(x_nums,y_nums),)\n\n    if Find:\n        # 获取更精确的角点位置(亚像素精度)\n        exact_corners = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)\n        # 获取外参，其中rvec是旋转矩阵，tvec是平移矩阵\n        _,rvec, tvec, inliers = cv2.solvePnPRansac(world_point, exact_corners, IntrinsicMatrix, distCoeffs)\n        # 获取两个平面(像素平面与实际平面)的映射关系,其中RMat是相机平面到Z=0轴的投影\n        Mat = cv2.findHomography(D_2_point, exact_corners)[0]\n        RMat = cv2.findHomography(exact_corners, D_2_point)[0]\n        \n        #print(np.transpose(np.dot(Mat,[[24.575*3,0],[0,24.575*3],[1,1]])))\n\n        # 这里打印的是一个投影的值\n        # 根据3D坐标，获取投影的二维坐标\n        imgpts, jac = cv2.projectPoints(axis, rvec, tvec, IntrinsicMatrix, distCoeffs)\n        # 可视化角点，画出图像\n        img = draw(image, corners, imgpts)\n        # cv2.imshow('img', img)\n        return [Mat,RMat,corners,imgpts]\n\n\n# 下面开始测距离\nif __name__ == '__main__':\n    # HSV特征提取，mask\n    # mask = [(0, 0, 159),(201, 218, 254)]\n    mask = (0, 0, 159),(201, 189, 240)\n    # 读取图像\n    #image = cv2.imread(sys.path[0]+\"/标定板位姿测量/aaa.png\")\n    images = glob.glob(sys.path[0]+\"/目标测量图像/aim?.png\")\n    mean_len_1=[]\n    mean_len_2=[]\n    Name = 1\n    for path in images:\n        image = cv2.imread(path)\n        image_2 = cv2.inRange(image,mask[0],mask[1])\n        a = []\n        b = []\n        dot = []\n        contours, hierarchy = cv2.findContours(image_2, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n        for contour in contours:\n            arclength = cv2.arcLength(contour, True)\n            # print(arclength)\n            a.append(arclength) # 长度保存在数组中\n        maxlen = max(a)\n        for contour in contours:\n            arclength = cv2.arcLength(contour, True)\n            if arclength == maxlen:\n                dot = cv2.approxPolyDP(contour,5,True)\n                dot = np.int0(dot)\n                cv2.drawContours(image, [dot], 0, (0, 0, 0), 1)\n\n        # 获得相机的外参与内参\n        # 从这里开始就开始测量图像了\n        # M是平面到平面的变化矩阵\n        M,M2,corners,imgpts = calibration_photo(photo_path)\n        img = draw(image, corners, imgpts)\n        # 保存图片\n        cv2.imwrite(sys.path[0]+'/建立坐标系/photo'+str(Name)+'.png',image)\n        Name = Name + 1\n        #cv2.imshow('',image)\n        b = np.ones(3)\n        c = np.ones((len(dot),3))\n        for i in range(len(dot)):\n            for j in range(2):\n                c[i][j] = dot[i][0][j]\n        # 转化到世界坐标系\n        word = np.transpose(np.dot(M2,np.transpose(c)))\n\n        for i in range(len(word)):\n            for j in range(2):\n                word[i][j] = word[i][j]/word[i][2]\n            word[i][2] = 0\n        print(\"世界坐标下的角点：\")\n        print(word)\n\n        # lon是长方形边长集合\n        lon = []\n        for i in range(len(word)):\n            lon.append(distance_2d(word[i-1],word[i]))\n        # 进行排序工作，矩形的特点可知，前两个属于短边，后两个属于长边\n        lon = np.sort(lon)\n        print(\"长方形边长的集合：\")\n        print(lon)\n        print(\"取平均数:\")\n        print(\"宽：\",(lon[0]+lon[1])/2,\"毫米\")\n        print(\"长：\",(lon[2]+lon[3])/2,\"毫米\")\n        print(\"\")\n        mean_len_1.append((lon[0]+lon[1])/2)\n        mean_len_2.append((lon[2]+lon[3])/2)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n\n    print(\"总平均宽度：\",np.mean(mean_len_1),\"毫米\")\n    print(\"总平均长度：\",np.mean(mean_len_2),\"毫米\")\n\n```\n\n## 5.4HSV提取部分的代码\n\n```python\n#! /usr/bin/env python3\n#! _*_ coding: utf-8 _*_\n\nimport cv2\nimport numpy as np\nimport sys\n\n#定义窗口名称\nwinName='HSV'\n#定义滑动条回调函数，此处pass用作占位语句保持程序结构的完整性\ndef nothing(x):\n    pass\nimg_original=cv2.imread(sys.path[0]+\"/目标测量图像/aim1.png\")\n# cv2.imshow('',img_original)\n[height,width] = [int(img_original.shape[0]/2), int(img_original.shape[1]/2)]           \n#根据照片尺寸设置高度和宽度,但是为了使降低分辨率的效果明显一点，我决定除以2\nimg_original = cv2.resize(img_original, (width, height))                  #选择照片尺寸\n\n#颜色空间的转换\nimg_hsv=cv2.cvtColor(img_original,cv2.COLOR_BGR2HSV)\n#新建窗口\ncv2.namedWindow(winName)\n#新建6个滑动条，表示颜色范围的上下边界，这里滑动条的初始化位置即为黄色的颜色范围\ncv2.createTrackbar('LowerbH',winName,0,255,nothing)\ncv2.createTrackbar('UpperbH',winName,0,255,nothing)\ncv2.createTrackbar('LowerbS',winName,0,255,nothing)\ncv2.createTrackbar('UpperbS',winName,0,255,nothing)\ncv2.createTrackbar('LowerbV',winName,0,255,nothing)\ncv2.createTrackbar('UpperbV',winName,0,255,nothing)\nwhile(1):\n    key = cv2.waitKey(1) & 0xff\n    #函数cv2.getTrackbarPos()范围当前滑块对应的值\n    lowerbH=cv2.getTrackbarPos('LowerbH',winName)\n    upperbH=cv2.getTrackbarPos('UpperbH',winName)\n    lowerbS=cv2.getTrackbarPos('LowerbS',winName)\n    upperbS=cv2.getTrackbarPos('UpperbS',winName)\n    lowerbV=cv2.getTrackbarPos('LowerbV',winName)\n    upperbV=cv2.getTrackbarPos('UpperbV',winName)\n    #得到目标颜色的二值图像，用作cv2.bitwise_and()的掩模\n    img_target=cv2.inRange(img_original,(lowerbH,lowerbS,lowerbV),(upperbH,upperbS,upperbV))\n    #输入图像与输入图像在掩模条件下按位与，得到掩模范围内的原图像\n    cv2.imshow(winName,img_target)\n    if key == ord('q'):\n        break\n\n# 在结束的时候打印出最后需要的结果\nprint((lowerbH,lowerbS,lowerbV),(upperbH,upperbS,upperbV))\n\ncv2.destroyAllWindows()\n\n\n```\n\n\n\n## 5.5作图代码\n\n求标准差以及方差的作图代码\n\n```matlab\nclc\nclear\nclose all\nx = [73.5666018,74.14032982,73.55856682,73.8470314,73.09076044,74.42260612,73.60488635,73.70609936,73.48301558,74.09237331];\ny = [117.96958408,118.58934466,118.28423093,118.85037165,117.98229763,118.75533294,117.94998985,118.78725115,118.52839878,118.72209685];\nSigma = cov([y' x']);\nmu=[118.44,73.75];% 均值向量\n[X,Y]=meshgrid(117:0.1:120,72:0.1:75);%在XOY面上，产生网格数据\np=mvnpdf([X(:) Y(:)],mu,Sigma);%求取联合概率密度，相当于Z轴\np=reshape(p,size(X));%将Z值对应到相应的坐标上\n\nfigure\nset(gcf,'Position',get(gcf,'Position').*[1 1 1.3 1])\n\nsubplot(2,3,[1 2 4 5])\nsurf(X,Y,p),axis tight,title('二维正态分布图')\nsubplot(2,3,3)\nsurf(X,Y,p),view(2),axis tight,title('在XOY面上的投影')\nsubplot(2,3,6)\nsurf(X,Y,p),view([0 0]),axis tight,title('在XOZ面上的投影')\n```\n\n标定结果分析作图的代码\n\n```python\n#! /usr/bin/env python3\n#! _*_ coding: utf-8 _*_\n\nimport matplotlib.pyplot as plt\nimport cv2\nimport sys\nimport glob\n\n\nimages = glob.glob(sys.path[0]+'/相机位姿测量/?.png')\na = 1\nsave_path = '/Users/mafumaful/Desktop/学习/./document/期末大作业-----------------/实验图片/photo.png'\nplt.rcParams['font.sans-serif'] = ['simhei']   \nfor image in images:\n    img = cv2.imread(image)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    plt.subplot(3,2,a)\n    plt.imshow(img)\n    plt.xticks([]),plt.yticks([])\n    a = a+1\n# plt.savefig(save_path,dpi = 200)\nplt.show()\n\n```\n\n长宽分布情况作图代码\n\n```python\n#! /usr/bin/env python3\n#! _*_ coding: utf-8 _*_\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = [73.5666018,74.14032982,73.55856682,73.8470314,73.09076044,74.42260612,73.60488635,73.70609936,73.48301558,74.09237331]\ny = [117.96958408,118.58934466,118.28423093,118.85037165,117.98229763,118.75533294,117.94998985,118.78725115,118.52839878,118.72209685]\n\nplt.rcParams['font.sans-serif'] = ['simhei'] \nplt.xlim((0, 80))\nplt.ylim((0, 150))\nplt.plot(x,y,'b*')\nplt.grid()\nplt.title(\"长宽分布情况\")\nplt.xlabel('宽(单位:mm)')\nplt.ylabel('长(单位:mm)')\ndef sq(s):\n    num = 0\n    for i in range(len(s)):\n        num = num + (s[i]-np.mean(s))**2\n    return np.sqrt(num/(len(s)-1))\nprint(sq(x))\nprint(sq(y))\nplt.show()\n```"}],"blogListPaginated":[{"items":["blog-post","welcome","calibrated-plane"],"metadata":{"permalink":"/blog","page":1,"postsPerPage":10,"totalPages":1,"totalCount":3,"blogDescription":"Blog","blogTitle":"Blog"}}],"blogTags":{"/blog/tags/hello":{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description","items":["blog-post","welcome"],"pages":[{"items":["blog-post","welcome"],"metadata":{"permalink":"/blog/tags/hello","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/docusaurus":{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description","items":["blog-post","welcome"],"pages":[{"items":["blog-post","welcome"],"metadata":{"permalink":"/blog/tags/docusaurus","page":1,"postsPerPage":10,"totalPages":1,"totalCount":2,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/facebook":{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description","items":["welcome"],"pages":[{"items":["welcome"],"metadata":{"permalink":"/blog/tags/facebook","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false},"/blog/tags/algorithm":{"inline":false,"label":"algorithm","permalink":"/blog/tags/algorithm","description":"algorithm tag description","items":["calibrated-plane"],"pages":[{"items":["calibrated-plane"],"metadata":{"permalink":"/blog/tags/algorithm","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false}},"blogTagsListPath":"/blog/tags","authorsMap":{"yangshun":{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"},"slorber":{"name":"Sébastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},"mafumaful":{"name":"mafumaful","title":"Student @ UWaterloo","url":"https://github.com/mafumaful","page":{"permalink":"/blog/authors/mafumaful"},"socials":{"x":"https://x.com/MasjfM","github":"https://github.com/mafumaful"},"imageURL":"https://github.com/mafumaful.png","key":"mafumaful"}}}},"docusaurus-plugin-content-pages":{"default":[{"type":"jsx","permalink":"/","source":"@site/src/pages/index.js"},{"type":"mdx","permalink":"/markdown-page","source":"@site/src/pages/markdown-page.md","title":"Markdown page example","description":"You don't need React to write simple standalone pages.","frontMatter":{"title":"Markdown page example"},"unlisted":false}]},"docusaurus-plugin-debug":{},"docusaurus-plugin-svgr":{},"docusaurus-theme-classic":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}